/**
 * Copyright (C) 2014-2017 Adrián González Sieira (adrian.gonzalez@usc.es)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package es.usc.citius.lab.motionplanner.core.spatial;

import es.usc.citius.lab.motionplanner.core.RepeatRule;
import es.usc.citius.lab.motionplanner.core.RepeatRule.Repeat;
import java.util.Random;

import es.usc.citius.lab.motionplanner.core.util.RandomUtils;
import org.apache.commons.math3.util.FastMath;
import org.ejml.data.DenseMatrix64F;
import org.ejml.simple.SimpleMatrix;
import static org.junit.Assert.*;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;

import static es.usc.citius.lab.motionplanner.core.spatial.Point2D.PRECISION;

/**
 * Test case for the functionalities of {@link Point2D}.
 *
 * @author Adrián González Sieira <a href=mailto:adrian.gonzalez@usc.es>adrian.gonzalez@usc.es</a>
 */
public class Point2DTest {
    
    @Rule
    public RepeatRule repeat = new RepeatRule();
    
    protected float x1, y1, x2, y2;
    protected Point2D point1;
    protected Point2D point2;
    protected static final float ERR = 1/PRECISION;
    protected static final float MAX = 50f;
    protected static final int EXECUTIONS = 10000;
    protected static final Random random = new Random();
    
    /**
     * Before each test obtains new values for x, y and a new instance
     * of {@link Point2D}.
     */ 
    @Before
    public void setUp() {
        //generate x, y coordinates randomly above the compare precision treshold
        x1 = RandomUtils.randomToValue(random.nextFloat(), MAX);
        y1 = RandomUtils.randomToValue(random.nextFloat(), MAX);
        do {
            x2 = RandomUtils.randomToValue(random.nextFloat(), MAX);
        } while (Math.abs(x2 - x1) < 1E-2);
        do{
            y2 = RandomUtils.randomToValue(random.nextFloat(), MAX);
        } while (Math.abs(y2 - y1) < 1E-2);

        //create new instance of point1
        point1 = new Point2D(x1, y1);
        point2 = new Point2D(x2, y2);
    }

    /**
     * Checks if the constructor generates the instances with the right content.
     */
    @Test
    @Repeat( times = EXECUTIONS)
    public void test_creation() {
        assertEquals("[create] wrong x value", x1, point1.x, ERR);
        assertEquals("[create] wrong y value", y1, point1.y, ERR);
        //obtain new instance from the last created
        Point2D test = new Point2D(point1);
        assertEquals("[clone] wrong x value", x1, test.x, ERR);
        assertEquals("[clone] wrong y value", y1, test.y, ERR);
    }
    
    /**
     * Checks the size and content of the matrix generated by the {@link Point2D}.
     */
    @Test
    @Repeat( times = EXECUTIONS)
    public void test_getMatrix(){
        //get matrix
        DenseMatrix64F matrix = point1.getMatrix();
        //check size
        assertTrue("[getMatrix] size is not 1x2", matrix.numRows == 2 && matrix.numCols == 1);
        //check elements
        assertEquals("[getMatrix] wrong x value", x1, matrix.get(0, 0), ERR);
        assertEquals("[getMatrix] wrong y value", y1, matrix.get(1, 0), ERR);
    }
    
    /**
     * Checks if equal instances have equal hashcodes, and if different instances have
     * different ones.
     */
    @Test
    @Repeat( times = EXECUTIONS)
    public void test_hashCode(){
        Point2D test = new Point2D(point1);
        Point2D test2 = new Point2D(point1.y, point1.x);
        assertEquals("[hashCode] wrong hashCode for equal instances", point1.hashCode(), test.hashCode());
        assertTrue("[hashCode] wrong hashCode", (point1.hashCode() == test2.hashCode()) == (Math.round(point1.x * PRECISION) == Math.round(test2.x * PRECISION) && Math.round(point1.y * PRECISION) == Math.round(test2.y * PRECISION)));
    }
    
    /**
     * Checks if equal instances are detected as equal elements, and different
     * ones not.
     */
    @Test
    @Repeat( times = EXECUTIONS)
    public void test_equals(){
        Point2D test = new Point2D(point1);
        Point2D test2 = new Point2D(point1.y, point1.x);
        assertEquals("[equals] wrong equals result for equal instances", point1, test);
        assertTrue("[equals] wrong equals result", point1.equals(test2) == (Math.round(point1.x * PRECISION) == Math.round(test2.x * PRECISION) && Math.round(point1.y * PRECISION) == Math.round(test2.y * PRECISION)));
    }
    
    /**
     * Checks if the angle between the point and (0, 0) is calculated
     * properly.
     */
    @Test
    @Repeat( times = EXECUTIONS)
    public void test_absoluteAngle1P(){
        //obtain angle to (0, 0)
        float test = point1.absoluteAngle();
        //expected result
        float expected = (float) FastMath.atan2(y1, x1);
        assertEquals("[absoluteAngle1P] wrong x value", expected, test, ERR);
    }
    
    /**
     * Checks if the angle between two points is calculated properly.
     */
    @Test
    @Repeat( times = EXECUTIONS)
    public void test_absoluteAngle2P(){
        //obtain angle to point2
        float test = point1.absoluteAngleTo(point2);
        //expected result
        float expected = (float) FastMath.atan2(y2 - y1, x2 - x1);
        assertEquals("[absoluteAngle2P] wrong value", expected, test, ERR);
    }
    
    /**
     * Checks the behavior of the method to calculate the angle between
     * the point and origin with known values.
     */
    @Test
    public void test_absoluteAngle1P_knownValues(){
        assertEquals("Angle from (0, 0) to (1, 1) and must be PI/4", FastMath.PI/4, new Point2D(1, 1).absoluteAngle(), ERR);
        assertEquals("Angle from (0, 0) to (2, 2) must be PI/4", FastMath.PI/4, new Point2D(2, 2).absoluteAngle(), ERR);
        assertEquals("Angle from (0, 0) to (0, 1) must be PI/2", FastMath.PI/2, new Point2D(0, 1).absoluteAngle(), ERR);
        assertEquals("Angle from (0, 0) to (0, 2) must be PI/2", FastMath.PI/2, new Point2D(0, 2).absoluteAngle(), ERR);
        assertEquals("Angle from (0, 0) to (0, -1) must be -PI/2", -FastMath.PI/2, new Point2D(0, -1).absoluteAngle(), ERR);
        assertEquals("Angle from (0, 0) to (0, -1) must be -PI/2", -FastMath.PI/2, new Point2D(0, -1).absoluteAngle(), ERR);
        assertEquals("Angle from (0, 0) to (-1, -1) must be -3*PI/4", -3*FastMath.PI/4, new Point2D(-1, -1).absoluteAngle(), ERR);
        assertEquals("Angle from (0, 0) to (1, -1) must be -PI/4", -FastMath.PI/4, new Point2D(1, -1).absoluteAngle(), ERR);
        assertEquals("Angle from (0, 0) to (-1, 1) must be 3*PI/4", 3*FastMath.PI/4, new Point2D(-1, 1).absoluteAngle(), ERR);
        assertEquals("Angle from (0, 0) to (-1, 0) must be PI", FastMath.PI, new Point2D(-1, 0).absoluteAngle(), ERR);
    }
    
    /**
     * Checks the behavior of the method to calculate the angle between two
     * points with known values.
     */
    @Test
    public void test_absoluteAngle2P_knownValues(){
        assertEquals("Angle from (1, 1) to (2, 2) must be PI/4", FastMath.PI/4, new Point2D(1, 1).absoluteAngleTo(new Point2D(2, 2)), ERR);
        assertEquals("Angle from (2, 2) to (3, 3) must be PI/4", FastMath.PI/4, new Point2D(2, 2).absoluteAngleTo(new Point2D(3, 3)), ERR);
        assertEquals("Angle from (3, 2) to (2, 2) must be -PI", FastMath.PI, new Point2D(3, 2).absoluteAngleTo(new Point2D(2, 2)), ERR);
        assertEquals("Angle from (2, 2) to (3, 2) must be 0", 0, new Point2D(2, 2).absoluteAngleTo(new Point2D(3, 2)), ERR);
        assertEquals("Angle from (2, 2) to (2, 3) must be PI/2", FastMath.PI/2, new Point2D(2, 2).absoluteAngleTo(new Point2D(2, 3)), ERR);
        assertEquals("Angle from (2, 2) to (3, 1) must be -PI/4", -FastMath.PI/4, new Point2D(2, 2).absoluteAngleTo(new Point2D(3, 1)), ERR);
        assertEquals("Angle from (1, 2) to (1, 1) must be -PI/2", -FastMath.PI/2, new Point2D(1, 2).absoluteAngleTo(new Point2D(1, 1)), ERR);
        assertEquals("Angle from (4, 5) to (3, 4) must be -3*PI/4", -3*FastMath.PI/4, new Point2D(4, 5).absoluteAngleTo(new Point2D(3, 4)), ERR);
        assertEquals("Angle from (4, 5) to (3, 6) must be 3*PI/4", 3*FastMath.PI/4, new Point2D(4, 5).absoluteAngleTo(new Point2D(3, 6)), ERR);
    }
    
    /**
     * Checks if the distance calculated between points is calculated properly.
     */
    @Test
    @Repeat( times = EXECUTIONS)
    public void test_distance(){
        //distance operation
        float distance = point1.distance(point2);
        //obtain expected
        float expected = (float) FastMath.sqrt(FastMath.pow(x1 - x2, 2) + FastMath.pow(y1 - y2, 2));
        assertEquals("[distance] wrong value", expected, distance, ERR);
    }
    
    /**
     * Checks if the adding operation is calculated properly.
     */
    @Test
    @Repeat( times = EXECUTIONS)
    public void test_add(){
        //calculate correct values
        float x = x1 + x2;
        float y = y1 + y2;
        //sum operation
        point1.staticAdd(point2);
        //checking
        assertEquals("[add] wrong x value", x, point1.x, ERR);
        assertEquals("[add] wrong x value", y, point1.y, ERR);
    }
    
    /**
     * Checks if the subtacting operation is calculated properly.
     */
    @Test
    @Repeat( times = EXECUTIONS)
    public void test_subtract(){
        //calculate correct values
        float x = x1 - x2;
        float y = y1 - y2;
        //subtract operation
        point1.staticSubtract(point2);
        //checking
        assertEquals("[subtract] wrong x value", x, point1.x, ERR);
        assertEquals("[subtract] wrong y value", y, point1.y, ERR);
    }
    
    /**
     * Checks if the rotation operation is calculated properly.
     */
    @Test
    @Repeat( times = EXECUTIONS)
    public void test_rotate(){
        //random angle
        float angle = (random.nextFloat() - 0.5f) * 2 * (float)FastMath.PI;
        //calculate correct values
        SimpleMatrix expected = new SimpleMatrix(new double[][]{{FastMath.cos(angle), -FastMath.sin(angle)}, {FastMath.sin(angle), FastMath.cos(angle)}}).mult(new SimpleMatrix(point1.getMatrix()));
        //rotate operation
        point1.staticRotate(angle, 0f, 0f);
        //checking
        assertEquals("[rotate] wrong x value", expected.get(0), point1.x, ERR);
        assertEquals("[rotate] wrong y value", expected.get(1), point1.y, ERR);
    }
    
    /**
     * Checks if the projection operation is calculated properly with a set of 
     * known cases.
     * 
     * @see http://www.sunshine2k.de/coding/java/PointOnLine/PointOnLine.html#step2
     */
    /*@Test
    @Repeat( times = EXECUTIONS)
    public void test_projectionLine(){
        //generate new random point to project
        Point2D point = new Point2D((random.nextFloat() - 0.5f) * MAX, (random.nextFloat() - 0.5f) * MAX);
        //result of the projection over the line point1<->point2
        Point2D result = point.projectOverLine(point1, point2);
        //calculate the area of the polygon formed by point1<->point2<->result
        float resultArea = FastMath.abs(perpDotProduct(point1, point2, result));
        //calculate the maximum area of the polygon to reject the test
        float maxArea = getEpsilon(point1, point2, point);
        //check the point is in the line between point1 and point2
        assertTrue("[projection] resulting area is higher than treshold", 
                resultArea <= maxArea);
        //check the angle of the lines point -> projection and point -> point2 to be 90º
        assertEquals("[projection] angle between projected point", 
                FastMath.PI / 2, 
                FastMath.abs(MathFunctions.errorBetweenAngles(result.absoluteAngleTo(point1), result.absoluteAngleTo(point))), 0.03);
    }*/
    
    /**
     * Checks if the projection operation is calculated properly with a set of 
     * known cases.
     * 
     * See www.sunshine2k.de/coding/java/PointOnLine/PointOnLine.html#step4
     */
    @Test
    @Repeat( times = EXECUTIONS)
    public void test_projectionSegment(){
        //generate new random point to project
        Point2D point = new Point2D((random.nextFloat() - 0.5f) * MAX, (random.nextFloat() - 0.5f) * MAX);
        //result of the projection over the line point1<->point2
        Point2D result = point.projectOverSegment(point1, point2);
        //calculate the area of the polygon formed by point1<->point2<->result
        float resultArea = FastMath.abs(perpDotProduct(point1, point2, result));
        //calculate the maximum area of the polygon to reject the test
        float maxArea = getEpsilon(point1, point2, point);
        assertTrue("[projection] resulting area is higher than treshold", 
                resultArea <= maxArea);
        assertTrue("[projection] resulting point is outside the segment", result.getX() >= FastMath.min(point1.getX(), point2.getX()) && result.getX() <= FastMath.max(point1.getX(), point2.getX()) && 
                result.getY() >= FastMath.min(point1.getY(), point2.getY()) && result.getY() <= FastMath.max(point1.getY(), point2.getY()));
    }
    
    /**
     * Calculates the area of the parallelogram of the three points. This is
     * actually the same as the area of the triangle defined by the three
     * points, multiplied by 2.
     *
     * @return 2 * triangleArea(a,b,c)
     */
    float perpDotProduct(Point2D a, Point2D b, Point2D c) {
        return (a.getX() - c.getX()) * (b.getY() - c.getY()) - (a.getY() - c.getY()) * (b.getX() - c.getX());
    }

    /**
     * Calculates the treshold to compare if the projected point is on the line 
     * between r1 and r2, given the area of the triangle formed by the points.
     * 
     * @param r1
     * @param r2
     * @param point proyection
     * @return treshold to compare if the area is == 0
     */
    public float getEpsilon(Point2D r1, Point2D r2, Point2D point) {
        float dx1 = FastMath.max(FastMath.max(FastMath.abs(r2.getX() - r1.getX()), FastMath.abs(r2.getX() - point.getX())), FastMath.abs(r1.getX() - point.getX()));
        float dy1 = FastMath.max(FastMath.max(FastMath.abs(r2.getY() - r1.getY()), FastMath.abs(r2.getY() - point.getY())), FastMath.abs(r1.getY() - point.getY()));
        return 0.05f * (dx1 * dx1 + dy1 * dy1);
    }
    
    /**
     * Checks if the (static) adding operation is calculated properly.
     */
    @Test
    @Repeat( times = EXECUTIONS)
    public void test_staticAdd(){
        //calculate correct values
        float x = x1 + x2;
        float y = y1 + y2;
        //static sum operation
        Point2D result = point1.add(point2);
        //checking
        assertEquals("[static add] wrong x value", x, result.x, ERR);
        assertEquals("[static add] wrong x value", y, result.y, ERR);
    }
    
    /**
     * Checks if the (static) subtacting operation is calculated properly.
     */
    @Test
    @Repeat( times = EXECUTIONS)
    public void test_staticSubtract(){
        //calculate correct values
        float x = x1 - x2;
        float y = y1 - y2;
        //static subtract operation
        Point2D result = point1.subtract(point2);
        //checking
        assertEquals("[static subtract] wrong x value", x, result.x, ERR);
        assertEquals("[static subtract] wrong y value", y, result.y, ERR);
    }
    
    /**
     * Checks if the rotation operation is calculated properly.
     */
    @Test
    @Repeat( times = EXECUTIONS)
    public void test_staticRotate(){
        //random angle
        float angle = (random.nextFloat() - 0.5f) * 2 * (float)FastMath.PI;
        //calculate correct values
        SimpleMatrix expected = new SimpleMatrix(new double[][]{{FastMath.cos(angle), -FastMath.sin(angle)}, {FastMath.sin(angle), FastMath.cos(angle)}}).mult(new SimpleMatrix(point1.getMatrix()));
        //rotate operation
        Point2D result = point1.rotate(angle, 0f, 0f);
        //checking
        assertEquals("[rotate] wrong x value", expected.get(0), result.x, ERR);
        assertEquals("[rotate] wrong y value", expected.get(1), result.y, ERR);
    }
}
